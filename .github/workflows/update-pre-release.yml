name: Update Pre-release

on:
  workflow_run:
    workflows: ["Build Desktop"] # Имя твоего workflow билда
    types: [completed]
    branches: [main] # Или другая ветка, на которой ты хочешь обновлять pre-release
  workflow_dispatch:
    inputs:
      build_id:
        description: 'ID успешного Workflow Run из "Build Desktop" (необязательно, если триггер не ручной)'
        required: false
        type: string
      package_version:
        description: 'Версия пакета (если не определяется из артефактов)'
        required: true
        type: string

jobs:
  update-pre-release:
    runs-on: ubuntu-latest
    # Условие можно упростить, так как оно проверяется внутри шагов тоже
    # if: ${{ github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    outputs:
      commit_sha: ${{ steps.get_info.outputs.commit_sha }} # Output commit SHA for clarity
      package_version: ${{ steps.get_info.outputs.package_version }} # Output determined package version
    steps:
      - name: Determine Trigger Info and Commit SHA # Определяем информацию о триггере и SHA коммита
        id: get_info
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            let commit_sha;
            let run_id_to_check;

            // 1. Получаем потенциальные версии. Выражение Actions вернет пустую строку (''), если input отсутствует.
            const envVersion = process.env.PACKAGE_VERSION;
            const inputVersion = "${{ github.event.inputs.package_version }}"; // Обратите внимание на кавычки вокруг выражения!

            // 2. Определяем фактическую версию с помощью JavaScript || и строки по умолчанию 'unknown'.
            let package_version = envVersion || inputVersion || 'unknown'; // Логика определения значения по умолчанию - чисто в JS

            if (context.eventName === 'workflow_run') {
              // ... (остальная часть блока if остается без изменений)
              if (context.payload.workflow_run.conclusion !== 'success') {
                 core.setFailed(`Запускающий workflow run ${context.payload.workflow_run.id} не был успешным.`);
                 return;
              }
              console.log("Запущено успешным workflow_run.");
              commit_sha = context.payload.workflow_run.head_commit.id;
              run_id_to_check = context.payload.workflow_run.id;
              // Здесь можно попытаться получить версию из вывода workflow сборки, если он ее предоставляет

            } else if (context.eventName === 'workflow_dispatch') {
              // ... (остальная часть блока else if остается без изменений)
               console.log("Запущено вручную через workflow_dispatch.");
               const run_id_str = "${{ github.event.inputs.build_id }}";
               if (!run_id_str) {
                 core.setFailed('Ручной запуск требует указания "build_id" в inputs.');
                 return;
               }
               const run_id = parseInt(run_id_str);
               if (isNaN(run_id)) {
                 core.setFailed(`Некорректный build ID: ${run_id_str}`);
                 return;
               }
               console.log(`Получение деталей для указанного вручную run ID: ${run_id}`);
               const run = await github.rest.actions.getWorkflowRun({ owner, repo, run_id });
               if (run.data.conclusion !== 'success') {
                 core.setFailed(`Workflow run ${run_id} не был успешным.`);
                 return;
               }
               commit_sha = run.data.head_commit.id;
               run_id_to_check = run_id;
               // package_version уже определена выше из env или inputVersion

            } else {
              core.setFailed(`Неподдерживаемый тип события: ${context.eventName}`);
              return;
            }

            if (!commit_sha) {
               core.setFailed("Не удалось определить SHA коммита.");
               return;
            }

            // Проверяем, не осталась ли версия 'unknown' после всех попыток ее определить
            if (package_version === 'unknown') {
               console.warn("Не удалось определить версию пакета из env или inputs. Используется 'unknown'. Возможно, стоит добавить шаг для чтения версии из артефактов.");
               // В зависимости от требований, можно завершить с ошибкой:
               // core.setFailed("Версия пакета не определена.");
               // return;
            }

            console.log(`Используется SHA коммита: ${commit_sha}`);
            console.log(`Артефакты будут загружены из run ID: ${run_id_to_check}`);
            console.log(`Версия пакета определена как: ${package_version}`);

            core.setOutput('commit_sha', commit_sha);
            core.setOutput('run_id_for_artifacts', run_id_to_check);
            core.setOutput('package_version', package_version);

      # Убедитесь, что у шага, определяющего версию, есть id, например, 'get_info' или 'read_version'
      # Пример:
      # - name: Determine Trigger Info and Commit SHA
      #   id: get_info
      #   ... outputs: package_version, run_id_for_artifacts ...

      - name: Debug Info Before Download
        run: |
          echo "Run ID for download: ${{ steps.get_info.outputs.run_id_for_artifacts }}"
          echo "Package Version for download: ${{ steps.get_info.outputs.package_version }}"
          echo "Expected Artifact Name: Bitwarden-Portable-${{ steps.get_info.outputs.package_version }}.exe"
        shell: bash

      - name: Download Portable exe artifact # <-- Шаг, который выдает ошибку
        uses: actions/download-artifact@v4
        with:
          name: Bitwarden-Portable-${{ steps.get_info.outputs.package_version }}.exe.zip
          path: artifacts/
          run-id: ${{ steps.get_info.outputs.run_id_for_artifacts }}
        # continue-on-error: true # Оставьте закомментированным для отладки

      - name: Download Installer exe artifact
        uses: actions/download-artifact@v4
        with:
          name: Bitwarden-Installer-${{ steps.get_info.outputs.package_version }}.exe # Точное имя артефакта
          path: artifacts/
          run-id: ${{ steps.get_info.outputs.run_id_for_artifacts }}
        # continue-on-error: true

      - name: Download NSIS ia32 artifact
        uses: actions/download-artifact@v4
        with:
          name: bitwarden-${{ steps.get_info.outputs.package_version }}-ia32.nsis.7z # Точное имя артефакта
          path: artifacts/
          run-id: ${{ steps.get_info.outputs.run_id_for_artifacts }}
        # continue-on-error: true

      - name: Download NSIS x64 artifact
        uses: actions/download-artifact@v4
        with:
          name: bitwarden-${{ steps.get_info.outputs.package_version }}-x64.nsis.7z # Точное имя артефакта
          path: artifacts/
          run-id: ${{ steps.get_info.outputs.run_id_for_artifacts }}
        # continue-on-error: true

      - name: Download NSIS ARM64 artifact
        uses: actions/download-artifact@v4
        with:
          name: bitwarden-${{ steps.get_info.outputs.package_version }}-arm64.nsis.7z # Точное имя артефакта
          path: artifacts/
          run-id: ${{ steps.get_info.outputs.run_id_for_artifacts }}
        # continue-on-error: true

      # Если нужен YML файл автообновления, добавьте шаг для его скачивания
      # - name: Download Auto-Update YML
      #   uses: actions/download-artifact@v4
      #   with:
      #     name: latest.yml # Или другое имя, как он загружается в Build Desktop
      #     path: artifacts/
      #     run-id: ${{ steps.get_info.outputs.run_id_for_artifacts }}
      #   # continue-on-error: true

      # Шаг для чтения версии из файла, если нужно
      # - name: Read package version from file
      #   id: read_version
      #   if: steps.get_info.outputs.package_version == 'unknown' # Если версия не была передана
      #   run: |
      #     # Пример: читаем из package.json, если он есть в артефактах
      #     if [ -f artifacts/package.json ]; then
      #       VERSION=$(jq -r .version artifacts/package.json)
      #       echo "package_version=$VERSION" >> $GITHUB_OUTPUT
      #     else
      #       echo "package_version=fallback-version" >> $GITHUB_OUTPUT # Или установить фолбэк
      #     fi

      - name: Create or update pre-release
        uses: actions/github-script@v6
        env:
           PACKAGE_VERSION: ${{ steps.get_info.outputs.package_version }} # Убедитесь, что версия передается
           # Или если читаете из файла: ${{ steps.read_version.outputs.package_version }}
           COMMIT_SHA: ${{ steps.get_info.outputs.commit_sha }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const commit_sha = process.env.COMMIT_SHA;
            const packageVersion = process.env.PACKAGE_VERSION;

            // Проверка версии (оставляем как было)
            if (!packageVersion || packageVersion === 'unknown') {
               core.setFailed("Package version could not be determined.");
               return;
            }
            if (!commit_sha) {
                core.setFailed("Commit SHA could not be determined.");
                return;
            }

            const targetReleaseName = 'Windows-CI-build'; // <--- Имя релиза, которое мы ищем и используем
            const artifactsPath = 'artifacts';
            const expectedTagName = `continuous-${packageVersion}`; // <--- Тег, который должен быть у этой версии

            console.log(`Используется версия пакета: ${packageVersion}`);
            console.log(`Используется SHA коммита: ${commit_sha}`);
            console.log(`Целевое имя пре-релиза: ${targetReleaseName}`);
            console.log(`Ожидаемый тег для этой версии: ${expectedTagName}`);

            // Собираем список артефактов для загрузки (оставляем как было)
            const artifactsToUpload = [
              { name: `Bitwarden-Portable-${packageVersion}.exe`, artifactPath: path.join(artifactsPath, `Bitwarden-Portable-${packageVersion}.exe`) },
              { name: `Bitwarden-Installer-${packageVersion}.exe`, artifactPath: path.join(artifactsPath, `Bitwarden-Installer-${packageVersion}.exe`) },
              { name: `bitwarden-${packageVersion}-ia32.nsis.7z`, artifactPath: path.join(artifactsPath, `bitwarden-${packageVersion}-ia32.nsis.7z`) },
              { name: `bitwarden-${packageVersion}-x64.nsis.7z`, artifactPath: path.join(artifactsPath, `bitwarden-${packageVersion}-x64.nsis.7z`) },
              { name: `bitwarden-${packageVersion}-arm64.nsis.7z`, artifactPath: path.join(artifactsPath, `bitwarden-${packageVersion}-arm64.nsis.7z`) },
              // { name: `latest.yml`, artifactPath: path.join(artifactsPath, `latest.yml`) }, // Если нужен YML
            ].filter(a => fs.existsSync(a.artifactPath));

            // Проверка наличия артефактов (оставляем как было)
            if (artifactsToUpload.length === 0) {
              console.log("Не найдены артефакты для загрузки в папке 'artifacts'.");
              return;
            }
            console.log("Артефакты для загрузки:", artifactsToUpload.map(a => a.name));

            // Функция загрузки ассета (оставляем как было)
            async function uploadAsset(releaseId, filePath, assetName) {
              const fileContent = fs.readFileSync(filePath);
              const fileSize = fs.statSync(filePath).size;
              console.log(`Загрузка ассета: ${assetName} из ${filePath} (${fileSize} bytes)`);
              try {
                await github.rest.repos.uploadReleaseAsset({
                  owner, repo, release_id: releaseId, name: assetName, data: fileContent,
                  headers: { 'Content-Type': 'application/octet-stream', 'Content-Length': fileSize },
                });
                console.log(`Ассет ${assetName} успешно загружен.`);
              } catch (error) {
                 console.error(`Не удалось загрузить ассет ${assetName}: ${error.message}`);
                 if (error.message.includes('already_exists')) { console.log(`Ассет ${assetName} уже существует. Пропускается.`); }
                 else { throw error; }
              }
            }

            // --- Логика поиска/создания/обновления релиза ---

            let release;
            console.log(`Поиск пре-релиза с именем: "${targetReleaseName}"`);
            const releases = await github.rest.repos.listReleases({ owner, repo });
            // Ищем существующий пре-релиз ТОЛЬКО по имени
            release = releases.data.find(r => r.prerelease && r.name === targetReleaseName);

            let releaseId;

            if (release) {
              // --- РЕЛИЗ НАЙДЕН - ОБНОВЛЯЕМ ---
              releaseId = release.id;
              console.log(`Найден существующий пре-релиз "${targetReleaseName}" с ID: ${releaseId}`);
              const currentTag = release.tag_name;

              // 1. Обновляем информацию о релизе (тег, коммит, описание)
              console.log(`Обновление существующего релиза (ID: ${releaseId})`);
              console.log(` - Целевой коммит: ${commit_sha}`);
              console.log(` - Целевой тег: ${expectedTagName} (Текущий тег: ${currentTag})`);
              await github.rest.repos.updateRelease({
                owner, repo, release_id: releaseId,
                tag_name: expectedTagName, // Устанавливаем тег для ЭТОЙ версии
                target_commitish: commit_sha, // Указываем коммит для ЭТОЙ версии
                name: targetReleaseName, // Имя оставляем тем же
                body: `Автоматически обновленный пре-релиз.\nКоммит: ${commit_sha.slice(0,7)}\nВерсия: ${packageVersion}`,
                prerelease: true
              });
              console.log("Информация о релизе обновлена.");

              // 2. Получаем список ВСЕХ существующих ассетов
              console.log("Получение списка существующих ассетов для удаления...");
              const { data: assets } = await github.rest.repos.listReleaseAssets({ owner, repo, release_id: releaseId });

              // 3. Удаляем ВСЕ старые ассеты
              console.log(`Найдено ${assets.length} ассетов для удаления.`);
              for (const asset of assets) { // Удаляем каждый ассет из списка
                console.log(`Удаление старого ассета: ${asset.name} (ID: ${asset.id})`);
                try {
                  await github.rest.repos.deleteReleaseAsset({ owner, repo, asset_id: asset.id });
                  console.log(`Ассет ${asset.name} удален.`);
                } catch (deleteError) {
                  console.error(`Не удалось удалить ассет ${asset.name} (ID: ${asset.id}): ${deleteError.message}`);
                  // Можно добавить логику повтора или пропустить ошибку
                }
              }
              console.log("Удаление старых ассетов завершено.");

            } else {
              // --- РЕЛИЗ НЕ НАЙДЕН - СОЗДАЕМ ---
              console.log(`Пре-релиз с именем "${targetReleaseName}" не найден. Создание нового...`);
              const newRelease = await github.rest.repos.createRelease({
                owner, repo,
                tag_name: expectedTagName, // Тег для новой версии
                name: targetReleaseName, // Имя, которое искали
                body: `Автоматически созданный пре-релиз.\nКоммит: ${commit_sha.slice(0,7)}\nВерсия: ${packageVersion}`,
                prerelease: true,
                target_commitish: commit_sha,
              });
              releaseId = newRelease.data.id;
              console.log(`Создан новый пре-релиз с ID: ${releaseId}`);
              // Старых ассетов для удаления нет
            }

            // --- Загрузка НОВЫХ ассетов ---
            console.log(`Загрузка ${artifactsToUpload.length} новых ассетов...`);
            for (const artifact of artifactsToUpload) {
               await uploadAsset(releaseId, artifact.artifactPath, artifact.name);
            }
            console.log("Загрузка новых ассетов успешно завершена.");
