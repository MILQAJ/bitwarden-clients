name: Sync Fork with Upstream

on:
  schedule:
    # Запуск в 05:00 UTC (соответствует 08:00 MSK - утро)
    - cron: '0 5 * * *'
    # Запуск в 09:00 UTC (соответствует 12:00 MSK - полдень)
    - cron: '0 9 * * *'
    # Запуск в 15:00 UTC (соответствует 18:00 MSK - вечер)
    - cron: '0 15 * * *'
    # Запуск в 21:00 UTC (соответствует 00:00 MSK - полночь)
    - cron: '0 21 * * *'
  workflow_dispatch: # Оставляем возможность ручного запуска
    inputs:
      branch_to_sync:
        description: 'Branch to sync (in your fork and upstream)'
        required: true
        default: 'main'

jobs:
  sync:
    name: Sync ${{ github.event.inputs.branch_to_sync || 'main' }} branch
    runs-on: ubuntu-latest
    # Даем права на запись в репозиторий (для git push)
    permissions:
      contents: write

    steps:
      # 1. Получаем код вашего форка
      - name: Checkout Fork
        uses: actions/checkout@v4 # Используйте актуальную версию
        with:
          ref: ${{ github.event.inputs.branch_to_sync || 'main' }} # Получаем нужную ветку
          # Используем токен для push обратно в репозиторий
          token: ${{ secrets.GITHUB_TOKEN }}
          # Получаем всю историю, чтобы избежать проблем при слиянии
          fetch-depth: 0

      # 2. Настраиваем Git (имя и email для коммитов слияния)
      - name: Set up Git config
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'

      # 3. Добавляем оригинальный репозиторий как remote "upstream"
      - name: Add upstream remote
        run: |
          # !!! ЗАМЕНИТЕ URL НА АДРЕС ОРИГИНАЛЬНОГО РЕПОЗИТОРИЯ !!!
          git remote add upstream https://github.com/bitwarden/clients.git # Пример для Bitwarden Clients

      # 4. Получаем изменения из upstream
      - name: Fetch upstream changes
        run: git fetch upstream

      - name: Check for new commits
        id: check_sync # ID шага для ссылки на output
        run: |
          # Получаем текущую ветку (main или из input)
          BRANCH="${{ github.event.inputs.branch_to_sync || 'main' }}"
          echo "Checking branch: $BRANCH"

          # Получаем SHA локальной ветки
          LOCAL_SHA=$(git rev-parse HEAD)
          echo "Local SHA: $LOCAL_SHA"

          # Получаем SHA соответствующей ветки upstream
          UPSTREAM_SHA=$(git rev-parse upstream/$BRANCH)
          echo "Upstream SHA: $UPSTREAM_SHA"

          # Сравниваем SHA и устанавливаем output
          if [[ "$LOCAL_SHA" == "$UPSTREAM_SHA" ]]; then
            echo "Ветка $BRANCH уже синхронизирована с upstream/$BRANCH."
            echo "is_up_to_date=true" >> $GITHUB_OUTPUT
          else
            # Подсчитаем количество новых коммитов (для информации)
            COMMIT_COUNT=$(git rev-list HEAD..upstream/$BRANCH --count)
            echo "Найдено $COMMIT_COUNT новых коммитов в upstream/$BRANCH."
            echo "is_up_to_date=false" >> $GITHUB_OUTPUT
          fi
        shell: bash # Используем bash для удобства сравнения строк

      - name: Fail workflow if no new commits found
        # Выполняем, ТОЛЬКО если is_up_to_date РАВНО true
        if: steps.check_sync.outputs.is_up_to_date == 'true'
        run: |
          echo "::warning::Нет новых коммитов для синхронизации. Завершаем workflow с ошибкой, чтобы не запускать последующие билды."
          exit 1 # Завершаем шаг (и весь job/workflow) с кодом ошибки > 0 = Failure

      # 5. Выполняем слияние ветки из upstream в вашу ветку
      - name: Merge upstream branch
      # Выполняем, только если is_up_to_date не true
        if: steps.check_sync.outputs.is_up_to_date != 'true'
        run: |
          git merge --no-edit upstream/${{ github.event.inputs.branch_to_sync || 'main' }}
          echo "Слияние выполнено."
        # Опция --no-edit используется, чтобы не открывать редактор для сообщения коммита слияния, если он понадобится

      # 6. Отправляем изменения (включая коммит слияния, если он был) обратно в ваш форк
      - name: Push changes to fork
      # Выполняем, только если is_up_to_date не true
        if: steps.check_sync.outputs.is_up_to_date != 'true'
        run: |
          git push origin ${{ github.event.inputs.branch_to_sync || 'main' }}
